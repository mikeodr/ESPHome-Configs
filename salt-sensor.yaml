esphome:
  name: salt-sensor
  friendly_name: salt-sensor

esp32:
  board: m5stack-atom
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret salt_sensor_api_key

esp32_ble_tracker:
  scan_parameters:
    active: true

bluetooth_proxy:
  active: true

ota:
  password: !secret ota_password
  platform: esphome

wifi:
  domain: !secret domain
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Salt-Sensor Fallback Hotspot"
    password: !secret fallback_password

captive_portal:

# Exposed switches.
button:
  # Switch to restart the esp.
  - platform: restart
    name: Restart

# i2c configuration entry for m5 Atom Lite
i2c:
  sda: 26
  scl: 32
  scan: true
  id: bus_a

light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    chipset: WS2812
    num_leds: 1
    pin: 27
    id: atom_led
    name: Status Light
    effects:
      - random:
      - flicker:
      - addressable_rainbow:

# Example configuration entry
sensor:
  - platform: uptime
    name: Uptime

  - platform: vl53l0x
    id: vl53l0x_distance
    i2c_id: bus_a
    name: "VL53L0x Distance"
    address: 0x29
    update_interval: 5s
    unit_of_measurement: "m"
    long_range: True
    filters:
      - sliding_window_moving_average:
          window_size: 60
          send_every: 10

  - platform: template
    name: "Salt Level"
    lambda: |-
      return id(vl53l0x_distance).state;
    unit_of_measurement: "%"
    filters:
      - calibrate_linear:
          method: exact
          datapoints:
            # Map 0.50m (from sensor) to 100% (full salt)
            - 0.50 -> 100
            # Map 0.735m (from sensor) to 0% (empty salt)
            - 0.735 -> 0
      - lambda: |
          if (x < 0) return 0;
          else if (x > 100) return 100;
          else return (x);
    accuracy_decimals: 0
